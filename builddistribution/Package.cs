using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace Arena.Custom.RC.Packager
{
    /// <summary>
    /// The Package class is a self-contained object that provides all
    /// the information needed to create and build a template that can
    /// be used to re-package new versions without having to
    /// re-construct the page.xml file each time. The Package class also
    /// provides the information needed to Export the page.xml that can
    /// then be loaded into Arena.
    /// </summary>
    public class Package
    {
        #region Properties

        /// <summary>
        /// Collection of File objects that will be associated with this
        /// Package and created in Arena during import.
        /// </summary>
        public FileCollection Files { get { return _Files; } }
        private FileCollection _Files;

        /// <summary>
        /// A collection of Modules that are a part of this Package. This is
        /// not the ModuleInstances, those are members of PageInstances.
        /// </summary>
        public ModuleCollection Modules { get { return _Modules; } }
        private ModuleCollection _Modules;

        /// <summary>
        /// The collection of root-level PageInstances in this Package. A Package
        /// should only have a single root-level page. However, loading an older
        /// Package could result in multiple root pages.
        /// </summary>
        public PageInstanceCollection Pages { get { return _Pages; } }
        private PageInstanceCollection _Pages;

        /// <summary>
        /// The Readme information associated with a Package. The Readme
        /// contents are displayed to the user during Import as "Important
        /// Information" that should be read before proceeding with the
        /// import operation.
        /// </summary>
        public String Readme { get; set; }

        #endregion

        /// <summary>
        /// Creates a new, empty, Package object that can then be loaded with
        /// data by the user.
        /// </summary>
        public Package()
        {
            _Files = new FileCollection(this);
            _Modules = new ModuleCollection(this);
            _Pages = new PageInstanceCollection(this);
            Readme = "";
        }

        /// <summary>
        /// Creates a new Package object by loading and parsing the data
        /// contained in the XmlDocument. The Package object can then be
        /// further edited or exported.
        /// </summary>
        /// <param name="doc">The XmlDocument that was generated by a previous call to Save.</param>
        public Package(XmlDocument doc)
            : this()
        {
            //
            // Load the readme.
            //
            if (doc.SelectSingleNode("//Readme") != null)
            {
                Readme = doc.SelectSingleNode("//Readme").InnerText;
            }

            //
            // Load the modules from the document.
            //
            foreach (XmlNode node in doc.SelectSingleNode("//ArenaPackage/Files").ChildNodes)
            {
                Files.Add(new File(node));
            }

            //
            // Load the modules from the document.
            //
            foreach (XmlNode node in doc.SelectSingleNode("//ArenaPackage/Modules").ChildNodes)
            {
                Modules.Add(new Module(node));
            }

            //
            // Load the pages from the document.
            //
            foreach (XmlNode node in doc.SelectSingleNode("//ArenaPackage/Pages").ChildNodes)
            {
                Pages.Add(new PageInstance(node));
            }
        }

        /// <summary>
        /// This method creates a new XmlDocument that contains all the
        /// information that is needed to re-load this Package object back
        /// into memory later for editing or Exporting to Arena. This method
        /// does not create an Xml document that can be used to Import directly
        /// into Arena.
        /// </summary>
        /// <returns>A XmlDocument that can be written to disc or other storage medium.</returns>
        public XmlDocument Save()
        {
            XmlDocument doc;
            XmlDeclaration decl;
            XmlNode nodeRoot, node;
            XmlAttribute attrib;


            //
            // Setup the XML document.
            //
            doc = new XmlDocument();
            decl = doc.CreateXmlDeclaration("1.0", "utf-8", null);
            doc.AppendChild(decl);
            nodeRoot = doc.CreateElement("ArenaPackage");
            attrib = doc.CreateAttribute("version");
            attrib.InnerText = "2009.2.100.1401";
            nodeRoot.Attributes.Append(attrib);
            doc.AppendChild(nodeRoot);

            //
            // Process the readme.
            //
            node = doc.CreateElement("Readme");
            node.InnerText = Readme;
            nodeRoot.AppendChild(node);

            //
            // Process the stand alone files.
            //
            node = doc.CreateElement("Files");
            foreach (File file in Files)
            {
                node.AppendChild(file.Save(doc));
            }
            nodeRoot.AppendChild(node);

            //
            // Process the modules.
            //
            node = doc.CreateElement("Modules");
            foreach (Module module in Modules)
            {
                node.AppendChild(module.Save(doc));
            }
            nodeRoot.AppendChild(node);

            //
            // Process the pages.
            //
            node = doc.CreateElement("Pages");
            foreach (PageInstance page in Pages)
            {
                node.AppendChild(page.Save(doc));
            }
            nodeRoot.AppendChild(node);

            return doc;
        }

        #region Traversal methods for determining next available ID numbers.
        
        /// <summary>
        /// Retrieves the next Module ID number that can be used in this
        /// Package.
        /// </summary>
        /// <returns>New ID number for a Module.</returns>
        internal int NextAvailableModuleID()
        {
            int nextID = -1;


            foreach (Module m in Modules)
            {
                if (m._ModuleID <= nextID)
                    nextID = m._ModuleID - 1;
            }

            return nextID;
        }

        /// <summary>
        /// Retrieves the next available PageInstance ID number that can be
        /// used in this Package.
        /// </summary>
        /// <returns>New PageInstance ID number.</returns>
        internal int NextAvailablePageID()
        {
            int nextID = -1;


            foreach (PageInstance page in Pages)
            {
                int tempID = NextAvailablePageID(page);

                if (tempID <= nextID)
                    nextID = tempID;
            }

            return nextID;
        }

        /// <summary>
        /// Retrieves the next available PageInstance ID number in the page
        /// heiarchy of the specified parent page. This method only determines
        /// what the lowest ID number in it's heiarchy would be, not for the
        /// entire Package. This method is recursive.
        /// </summary>
        /// <param name="parentPage">The PageInstance to begin searching at.</param>
        /// <returns>Next available ID number for a new page under the parent page.</returns>
        private int NextAvailablePageID(PageInstance parentPage)
        {
            int nextID = -1;


            if (parentPage == null)
                return -1;

            if (parentPage._PageID <= nextID)
                nextID = parentPage._PageID - 1;

            foreach (PageInstance page in parentPage.Pages)
            {
                if (page._PageID <= nextID)
                    nextID = page._PageID;
            }

            return nextID;
        }

        /// <summary>
        /// Determines the next available module instance ID number that can be used
        /// for a new ModuleInstance in this Package.
        /// </summary>
        /// <returns>Next available ModuleInstance ID number in this Package.</returns>
        internal int NextAvailableModuleInstanceID()
        {
            int nextID = -1;


            foreach (PageInstance page in Pages)
            {
                int tempID = NextAvailableModuleInstanceID(page);

                if (tempID <= nextID)
                    nextID = tempID;
            }

            return nextID;
        }

        /// <summary>
        /// Determines the next available module instance ID number in the
        /// page heiarchy of the identified parent PageInstance. This search
        /// is recursive. This method does not guarentee that the returned ID
        /// number is the next one that should be used, only the next lowest
        /// number under this page.
        /// </summary>
        /// <param name="parentPage">The PageInstance to begin at.</param>
        /// <returns>The next available module instance ID that can be used under this page.</returns>
        private int NextAvailableModuleInstanceID(PageInstance parentPage)
        {
            int nextID = -1;


            if (parentPage == null)
                return -1;

            foreach (PageInstance page in parentPage.Pages)
            {
                int tempID = NextAvailableModuleInstanceID(page);

                if (tempID <= nextID)
                    nextID = tempID;
            }

            foreach (ModuleInstance module in parentPage.Modules)
            {
                int tempID = module._ModuleInstanceID;

                if (tempID <= nextID)
                    nextID = tempID - 1;
            }

            return nextID;
        }

        #endregion

        #region Traversal methods for determining parentage.

        /// <summary>
        /// Searches all PageInstances in the Package and determines which page
        /// contains the specified page as it's direct child.
        /// </summary>
        /// <param name="page">The child page to search for.</param>
        /// <returns>The parent PageInstance containing the child page or null if not found.</returns>
        public PageInstance ParentOfPage(PageInstance page)
        {
            foreach (PageInstance parent in Pages)
            {
                PageInstance parentPage = ParentOfPage(parent, page);

                if (parentPage != null)
                    return parentPage;
            }

            return null;
        }

        /// <summary>
        /// Searches the heiarchy of the specified PageInstance and determines
        /// which page, if any, contains the identified child page. This method is
        /// recursive.
        /// </summary>
        /// <param name="parentPage">The parent to begin searching at.</param>
        /// <param name="page">The child page to search for.</param>
        /// <returns>The PageInstance containing the child page or null if not found.</returns>
        private PageInstance ParentOfPage(PageInstance parentPage, PageInstance page)
        {
            if (parentPage.Pages.Contains(page))
                return parentPage;

            foreach (PageInstance parent in parentPage.Pages)
            {
                PageInstance tmp = ParentOfPage(parent, page);

                if (tmp != null)
                    return tmp;
            }

            return null;
        }

        /// <summary>
        /// Finds the page that contains the specified ModuleInstance. If no page
        /// in this Package contains the ModuleInstance then null is returned.
        /// </summary>
        /// <param name="module">The ModuleInstance to search for.</param>
        /// <returns>The PageInstance that contains the ModuleInstance or null if not found.</returns>
        public PageInstance ParentOfModule(ModuleInstance module)
        {
            foreach (PageInstance parent in Pages)
            {
                PageInstance parentPage = ParentOfModule(parent, module);

                if (parentPage != null)
                    return parentPage;
            }

            return null;
        }

        /// <summary>
        /// Determine if the module is on either the specified page or a child
        /// page and returns the matching page. This method is recursive.
        /// </summary>
        /// <param name="parentPage">The PageInstance to begin searching at.</param>
        /// <param name="module">The ModuleInstance to look for.</param>
        /// <returns>PageInstance containing module or null if not found.</returns>
        private PageInstance ParentOfModule(PageInstance parentPage, ModuleInstance module)
        {
            if (parentPage.Modules.Contains(module))
                return parentPage;

            foreach (PageInstance parent in parentPage.Pages)
            {
                PageInstance tmp = ParentOfModule(parent, module);

                if (tmp != null)
                    return tmp;
            }

            return null;
        }

        #endregion
    }
}
